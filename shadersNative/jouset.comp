#version 430

uniform float h = 0.1;
uniform float k = 0.1;
uniform vec4 gravity = vec4(0.0,-9.81,0.0,0.0);
uniform float phase = 1.0;
uniform float mass = 0.1;
uniform float viskositeettiKerroin = 0.1;
//uniform float rest = 1.414214; 

struct PVdata
{
  vec4 pos;
  vec4 vel;
};

struct StaticData
{
  vec4 some_data;
  vec4 friends;
  vec4 rest_forces;
};

layout (local_size_x = 90,local_size_y=1,local_size_z=1) in;

layout (std430, binding = 0) buffer InitialBuf { PVdata initial[]; };
layout (std430, binding = 1) buffer TempBuf { PVdata temp[]; };
layout (std430, binding = 2) buffer StaticBuf { StaticData static_data[]; };
layout (std430, binding = 3) buffer K1 { vec4 k1[]; };
layout (std430, binding = 4) buffer K2 { vec4 k2[]; };
layout (std430, binding = 5) buffer K3 { vec4 k3[]; };
layout (std430, binding = 6) buffer K4 { vec4 k4[]; };

///////////////////////////////////////////////////////////////////////////

// TODO: lepopituudet.
vec4 laske_voima(vec4 posA, vec4 posB, float r) {

  vec3 d = posB.xyz - posA.xyz;
  return 1.0 * k * (length(d) - r) * vec4(normalize(d),0.0); // dist;  
}

///////////////////////////////////////////////////////////////////////////

PVdata getParticle(uint index) {
  if (phase == 1.0) return initial[index]; 
  else return temp[index];
}

///////////////////////////////////////////////////////////////////////////

void evalF_flex(uint index) {

   // Haetaan partikkelin alkuperainen sijainti ja velocity.
   PVdata pv_initial = initial[index];
   PVdata pv_now = getParticle(index);

   // k5.
   if (phase == 5.0) {
     PVdata final_data;
     vec4 final_force = (1.0/6.0) * h * (k1[index] + 2*k2[index] + 2*k3[index] + k4[index]); 
     final_data.pos = pv_initial.pos + final_force;  
     final_data.vel = pv_initial.vel + final_force;  
     initial[index] = final_data;
     return;
   }

   // kaverit, lepo-pituudet ym.
   StaticData sd = static_data[index]; 

   // Onko staattinen partikkeli; -1.0 staattinen.
   float is_static = sd.some_data.x;

   // Tahan voima.
   vec4 force = gravity * mass;

   // Kaveri indeksit.
   float friend0 = sd.friends[0]; 
   float friend1 = sd.friends[1]; 
   float friend2 = sd.friends[2]; 
   float friend3 = sd.friends[3]; 

   // Lepo-pituudet.
   float rest0 = sd.rest_forces[0]; 
   float rest1 = sd.rest_forces[1]; 
   float rest2 = sd.rest_forces[2]; 
   float rest3 = sd.rest_forces[3]; 

   // Jos on kaveri olemassa, niin lasketaan voima.
   if (friend0 != -1.0) {
     force = force + laske_voima(pv_now.pos, getParticle(uint(friend0)).pos, rest0);
   }

   if (friend1 != -1.0) {
     force = force + laske_voima(pv_now.pos, getParticle(uint(friend1)).pos, rest1);
   }

   if (friend2 != -1.0) {
     force = force + laske_voima(pv_now.pos, getParticle(uint(friend2)).pos, rest2);
   }

   if (friend3 != -1.0) {
     force = force + laske_voima(pv_now.pos, getParticle(uint(friend3)).pos, rest3);
   }

   force = force - pv_now.vel * viskositeettiKerroin;
   force = force * 1.0/mass;
   force = force + pv_now.vel;

   if (is_static == -1.0) force = vec4(0.0);

   if (phase == 1.0) {
     PVdata new_data;
     new_data.pos = pv_initial.pos + 0.5 * h * force;  
     new_data.vel = pv_now.vel + 0.5 * h * force;  
     temp[index] = new_data;
     //k1[index] = pv_now.vel + h * force;
     k1[index] = h * force;
   }

   else if (phase == 2.0) {
     PVdata new_data;
     new_data.pos = pv_initial.pos + 0.5 * h * force;  
     new_data.vel = pv_initial.vel + 0.5 * h * force;  
     temp[index] = new_data;
     //k2[index] = pv_now.vel + h * force;
     k2[index] = h * force;
   }

   else if (phase == 3.0) {
     PVdata new_data;
     new_data.pos = pv_initial.pos + h * force;  
     new_data.vel = pv_initial.vel + h * force;  
     temp[index] = new_data;
     //k3[index] = pv_now.vel + h * force;
     k3[index] = h * force;
   }

   else if (phase == 4.0) {
     //PVdata new_data;
     //k4[index] = pv_now.vel + h * force;
     k4[index] = h * force;
   }

   // k1.
//   if (phase == 1.0) {
//     PVdata new_data;
//     new_data.pos = pv_initial.pos + pv_now.vel * 0.5 * h * force;  
//     new_data.vel = pv_now.vel + 0.5 * h * force;  
//     temp[index] = new_data;
//     //k1[index] = pv_now.vel + h * force;
//     k1[index] = pv_now.vel * h * force;
//   }
//
//   else if (phase == 2.0) {
//     PVdata new_data;
//     new_data.pos = pv_initial.pos + pv_now.vel * 0.5 * h * force;  
//     new_data.vel = pv_initial.vel + 0.5 * h * force;  
//     temp[index] = new_data;
//     //k2[index] = pv_now.vel + h * force;
//     k2[index] = pv_now.vel * h * force;
//   }
//
//   else if (phase == 3.0) {
//     PVdata new_data;
//     new_data.pos = pv_initial.pos + pv_now.vel * h * force;  
//     new_data.vel = pv_initial.vel + h * force;  
//     temp[index] = new_data;
//     //k3[index] = pv_now.vel + h * force;
//     k3[index] = pv_now.vel * h * force;
//   }
//
//   else if (phase == 4.0) {
//     //PVdata new_data;
//     //k4[index] = pv_now.vel + h * force;
//     k4[index] = pv_now.vel * h * force;
//   }

}

///////////////////////////////////////////////////////////////////////////

void main()
{
  uint pos = gl_GlobalInvocationID.x;
  //PVdata joo;
  //joo.pos = vec4(pos);
  //joo.vel = vec4(6.666);
  //initial[pos] = joo;
  evalF_flex(pos);
}
